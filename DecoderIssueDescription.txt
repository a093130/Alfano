In GenerateControlTable.py, in order to write out Control.json, I have created a numpy ndarray decoder per
https://stackoverflow.com/questions/27909658/json-encoder-and-decoder-for-complex-numpy-arrays

When I run it to serialize the dictionary with a nested ndarray, I get an exception,
TypeError: __init__() takes 1 positional argument but 3 were given

Dump(args looks like

`{-0.1186: array([0.1   , 0.1004, 0.1009, ..., 0.3255 ]),
-0.1194: array([0.1006, 0.101, ..., 0.3285]),
...
-1.5686: array([0.9994, 0., 0., ..., 0.])}`

See file "JSON_Dump(args).txt.

The truncated JSON file output is: '{"-0.1186": {"__ndarray__":'

This is incomplete at the first element, so it seems the encoder must have completed the dictionary and is attempting to express the array values.

[ANALYSIS]
Use the debugger to step through code.

[RESULT]

Debug session ends with TypeError Exception after writing 12 "chunks" of args to the passed-in file pointer.  Encoder.py is the central actor.  As follows.

ipdb> > c:\users\chelm\documents\workingfolder\projectroot\projects\gmat\alfano\generatecontroltable.py(180)dump()
    178     """ Overload dump use NumpyEncoder. """
1   179     kwargs.setdefault('cls', NumpyEncoder)
--> 180     return js.dump(*args, **kwargs)
    181 
    182 def load(*args, **kwargs):

ipdb> --Call--
> c:\users\chelm\anaconda3\lib\json\__init__.py(120)dump()
    118 )
    119 
--> 120 def dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True,
    121         allow_nan=True, cls=None, indent=None, separators=None,
    122         default=None, sort_keys=False, **kw):

ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(165)dump()
    163     """
    164     # cached encoder
--> 165     if (not skipkeys and ensure_ascii and
    166         check_circular and allow_nan and
    167         cls is None and indent is None and separators is None and
       cls is None and indent is None and separators is None and

ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(171)dump()
    169         iterable = _default_encoder.iterencode(obj)
    170     else:
--> 171         if cls is None:
    172             cls = JSONEncoder
    173         iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,

ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(173)dump()
    171         if cls is None:
    172             cls = JSONEncoder
--> 173         iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,
    174             check_circular=check_circular, allow_nan=allow_nan, indent=indent,
    175             separators=separators,

ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(176)dump()
    174             check_circular=check_circular, allow_nan=allow_nan, indent=indent,
    175             separators=separators,
--> 176             default=default, sort_keys=sort_keys, **kw).iterencode(obj)
    177     # could accelerate with writelines in some versions of Python, at
    178     # a debuggability cost

ipdb> --Call--
> c:\users\chelm\anaconda3\lib\json\encoder.py(104)__init__()
    102     item_separator = ', '
    103     key_separator = ': '
--> 104     def __init__(self, *, skipkeys=False, ensure_ascii=True,
    105             check_circular=True, allow_nan=True, sort_keys=False,
    106             indent=None, separators=None, default=None):

ipdb> > c:\users\chelm\anaconda3\lib\json\encoder.py(147)__init__()
    145         """
    146 
--> 147         self.skipkeys = skipkeys
    148         self.ensure_ascii = ensure_ascii
    149         self.check_circular = check_circular
    150         self.allow_nan = allow_nan

ipdb> > c:\users\chelm\anaconda3\lib\json\encoder.py(153)__init__()
    151         self.sort_keys = sort_keys
    152         self.indent = indent
--> 153         if separators is not None:
    154             self.item_separator, self.key_separator = separators
    155         elif indent is not None:

ipdb> > c:\users\chelm\anaconda3\lib\json\encoder.py(155)__init__()
    153         if separators is not None:
    154             self.item_separator, self.key_separator = separators
--> 155         elif indent is not None:
    156             self.item_separator = ','
    157         if default is not None:

ipdb> > c:\users\chelm\anaconda3\lib\json\encoder.py(157)__init__()
    155         elif indent is not None:
    156             self.item_separator = ','
--> 157         if default is not None:
    158             self.default = default
    159 

ipdb> --Return--
None
> c:\users\chelm\anaconda3\lib\json\encoder.py(157)__init__()
    155         elif indent is not None:
    156             self.item_separator = ','
--> 157         if default is not None:
    158             self.default = default
    159 

ipdb> --Call--
> c:\users\chelm\anaconda3\lib\json\encoder.py(204)iterencode()
    202         return ''.join(chunks)
    203 
--> 204     def iterencode(self, o, _one_shot=False):
    205         """Encode the given object and yield each string
    206         representation as available.

ipdb> > c:\users\chelm\anaconda3\lib\json\encoder.py(214)iterencode()
    212 
    213         """
--> 214         if self.check_circular:
--> 215             markers = {}
    216         else:
    217             markers = None
--> 218         if self.ensure_ascii:
--> 219             _encoder = encode_basestring_ascii
    220         else:
    221             _encoder = encode_basestring
    222 
    223         def floatstr(o, allow_nan=self.allow_nan,
--> 224                 _repr=float.__repr__, _inf=INFINITY, _neginf=-INFINITY):
    225             # Check for specials.  Note that this type of test is processor
    226             # and/or platform-specific, so do tests which don't depend on the

ipdb> > c:\users\chelm\anaconda3\lib\json\encoder.py(246)iterencode()
    244 
    245 
--> 246         if (_one_shot and c_make_encoder is not None
    247                 and self.indent is None):
    248             _iterencode = c_make_encoder(


ipdb> > c:\users\chelm\anaconda3\lib\json\encoder.py(253)iterencode()
    251                 self.skipkeys, self.allow_nan)
    252         else:
--> 253             _iterencode = _make_iterencode(
    254                 markers, self.default, _encoder, self.indent, floatstr,
--> 255                 self.key_separator, self.item_separator, self.sort_keys,
    256                 self.skipkeys, _one_shot)

ipdb> --Return--
<generator ob...00256BA9BD678>
> c:\users\chelm\anaconda3\lib\json\encoder.py(257)iterencode()
--> 257         return _iterencode(o, 0)


ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(179)dump()
    177     # could accelerate with writelines in some versions of Python, at
    178     # a debuggability cost
--> 179     for chunk in iterable:
    180         fp.write(chunk)

ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(180)dump()
    179     for chunk in iterable:
--> 180         fp.write(chunk)



ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(179)dump()
--> 179     for chunk in iterable:
    180         fp.write(chunk)
 

ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(180)dump()
    179     for chunk in iterable:
--> 180         fp.write(chunk)
 

ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(179)dump()
--> 179     for chunk in iterable:
    180         fp.write(chunk)

ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(180)dump()
    179     for chunk in iterable:
--> 180         fp.write(chunk)


ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(179)dump()
--> 179     for chunk in iterable:
    180         fp.write(chunk)


ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(180)dump()
    179     for chunk in iterable:
--> 180         fp.write(chunk)


ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(179)dump()
--> 179     for chunk in iterable:
    180         fp.write(chunk)


ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(180)dump()
    179     for chunk in iterable:
--> 180         fp.write(chunk)
 

ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(179)dump()
--> 179     for chunk in iterable:
    180         fp.write(chunk)

ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(180)dump()
    179     for chunk in iterable:
--> 180         fp.write(chunk)


ipdb> > c:\users\chelm\anaconda3\lib\json\__init__.py(179)dump()
--> 179     for chunk in iterable:
    180         fp.write(chunk)
    181

ipdb> TypeError: __init__() takes 1 positional argument but 3 were given


ipdb> --Return--

ipdb> TypeError: __init__() takes 1 positional argument but 3 were given
> c:\users\chelm\documents\workingfolder\projectroot\projects\gmat\alfano\generatecontroltable.py(180)dump()
    178     """ Overload dump use NumpyEncoder. """
1   179     kwargs.setdefault('cls', NumpyEncoder)
--> 180     return js.dump(*args, **kwargs)




Second Trace with breakpoint in NumpyEncoder
First breakpoint, default has been called by encoder.py normally, and results are returned.
The return value is stored as "o" and code at 436 - 438 is executed
The next call to default ends up falling through to line 199, where the base class is called to raise the TypeError.



Writing U column vector for costate -1.5686
> c:\users\chelm\documents\workingfolder\projectroot\projects\gmat\alfano\generatecontroltable.py(197)default()
    195             """ Proximous caught a bug in Adam Hughes' code """
    196 
1-> 197             return dict(__ndarray__=data_b64, dtype=str(obj.dtype), shape=obj.shape)
    198         # Let the base class default method raise the TypeError
2   199         return js.JSONEncoder(self, obj)


ipdb> --Return--
{'__ndarray__': b'mpmZmZmZuT/.../okW28/3U1D8=', 'dtype': 'float64', 'shape': (901,)}
> c:\users\chelm\documents\workingfolder\projectroot\projects\gmat\alfano\generatecontroltable.py(197)default()
    195             """ Proximous caught a bug in Adam Hughes' code """
    196 
1-> 197             return dict(__ndarray__=data_b64, dtype=str(obj.dtype), shape=obj.shape)
    198         # Let the base class default method raise the TypeError
2   199         return js.JSONEncoder(self, obj)


ipdb> > c:\users\chelm\anaconda3\lib\json\encoder.py(438)_iterencode()
    436                 markers[markerid] = o
    437             o = _default(o)
--> 438             yield from _iterencode(o, _current_indent_level)
    439             if markers is not None:
    440                 del markers[markerid]


ipdb> > c:\users\chelm\documents\workingfolder\projectroot\projects\gmat\alfano\generatecontroltable.py(199)default()
1   197             return dict(__ndarray__=data_b64, dtype=str(obj.dtype), shape=obj.shape)
    198         # Let the base class default method raise the TypeError
2-> 199         return js.JSONEncoder(self, obj)
    200     """ Thanks to Adam Hughes, hpaulj and Proximous on Stack Overflow,
    201     https://stackoverflow.com/questions/27909658/


ipdb> TypeError: __init__() takes 1 positional argument but 3 were given
> c:\users\chelm\documents\workingfolder\projectroot\projects\gmat\alfano\generatecontroltable.py(199)default()
1   197             return dict(__ndarray__=data_b64, dtype=str(obj.dtype), shape=obj.shape)
    198         # Let the base class default method raise the TypeError
2-> 199         return js.JSONEncoder(self, obj)
    200     """ Thanks to Adam Hughes, hpaulj and Proximous on Stack Overflow,
    201     https://stackoverflow.com/questions/27909658/


ipdb> --Return--
None
> c:\users\chelm\documents\workingfolder\projectroot\projects\gmat\alfano\generatecontroltable.py(199)default()
1   197             return dict(__ndarray__=data_b64, dtype=str(obj.dtype), shape=obj.shape)
    198         # Let the base class default method raise the TypeError
2-> 199         return js.JSONEncoder(self, obj)
    200     """ Thanks to Adam Hughes, hpaulj and Proximous on Stack Overflow,
    201     https://stackoverflow.com/questions/27909658/


ipdb> TypeError: __init__() takes 1 positional argument but 3 were given
> c:\users\chelm\anaconda3\lib\json\encoder.py(437)_iterencode()
    435                     raise ValueError("Circular reference detected")
    436                 markers[markerid] = o
--> 437             o = _default(o)
    438             yield from _iterencode(o, _current_indent_level)
    439             if markers is not None:
 
ipdb> --Return--
None
> c:\users\chelm\anaconda3\lib\json\encoder.py(437)_iterencode()
    435                     raise ValueError("Circular reference detected")
    436                 markers[markerid] = o
--> 437             o = _default(o)
    438             yield from _iterencode(o, _current_indent_level)
    439             if markers is not None:


ipdb> TypeError: __init__() takes 1 positional argument but 3 were given
> c:\users\chelm\anaconda3\lib\json\encoder.py(404)_iterencode_dict()
    402                 else:
    403                     chunks = _iterencode(value, _current_indent_level)
--> 404                 yield from chunks
    405         if newline_indent is not None:
    406             _current_indent_level -= 1


ipdb> --Return--
None
> c:\users\chelm\anaconda3\lib\json\encoder.py(404)_iterencode_dict()
    402                 else:
    403                     chunks = _iterencode(value, _current_indent_level)
--> 404                 yield from chunks
    405         if newline_indent is not None:
    406             _current_indent_level -= 1


ipdb> TypeError: __init__() takes 1 positional argument but 3 were given
> c:\users\chelm\anaconda3\lib\json\encoder.py(430)_iterencode()
    428             yield from _iterencode_list(o, _current_indent_level)
    429         elif isinstance(o, dict):
--> 430             yield from _iterencode_dict(o, _current_indent_level)
    431         else:
    432             if markers is not None:


ipdb> --Return--
None
> c:\users\chelm\anaconda3\lib\json\encoder.py(430)_iterencode()
    428             yield from _iterencode_list(o, _current_indent_level)
    429         elif isinstance(o, dict):
--> 430             yield from _iterencode_dict(o, _current_indent_level)
    431         else:
    432             if markers is not None:


ipdb> TypeError: __init__() takes 1 positional argument but 3 were given
> c:\users\chelm\anaconda3\lib\json\encoder.py(438)_iterencode()
    436                 markers[markerid] = o
    437             o = _default(o)
--> 438             yield from _iterencode(o, _current_indent_level)
    439             if markers is not None:
    440                 del markers[markerid]


[FIX]
So it looks like when the Default method falls through to call the JSONEncoder, the __init__ method only provides one positional argument.  One diagnostic change may be to raise TypeError in the Default method.  The state could be logged that way. Why is default called for an object it can't decode?  What object is that?

[RESULT]
NumpyEncoder fell through for type <class 'bytes'>.
08April2019_10:02:11 GenerateControlTable.py ERROR:
Exception writing JSON file: Inappropriate argument type.
Traceback (most recent call last):
TypeError: Object of type 'bytes' is not JSON serializable.

[ANALYSIS]
The first debugging session , in iterencode(), clearly shows that the array is supposed to be encoded as a floatstr(), see line 223.
    204     def iterencode(self, o, _one_shot=False):
    205         """Encode the given object and yield each string
    206         representation as available.
    ...
    212 
    213         """
--> 214         if self.check_circular:
--> 215             markers = {}
    216         else:
    217             markers = None
--> 218         if self.ensure_ascii:
--> 219             _encoder = encode_basestring_ascii
    220         else:
    221             _encoder = encode_basestring
    222 
    223         def floatstr(o, allow_nan=self.allow_nan,
--> 224                 _repr=float.__repr__, _inf=INFINITY, _neginf=-INFINITY):
    225             # Check for specials.  Note that this type of test is processor
    226             # and/or platform-specific, so do tests which don't depend on the

Numpy::Encoder is encoding the obj.data as data_b64.  From documentation,
base64.b64encode(s, altchars=None): Encode the bytes-like object s using Base64 and return the encoded bytes.

[Fix]
At line 169,
Was:
data_b64 = base64.b64encode(np.ascontiguousarray(obj).data)
Is:
data_b64 = repr(base64.b64encode(np.ascontiguousarray(obj).data))

[RESULT]
Seems to work.  

[VERIFIED]
JSON file is written out.

[CLOSE]